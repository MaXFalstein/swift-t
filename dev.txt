
////
Swift/T developers' guide, asciidoc format
http://swift-lang.github.io/swift-t/dev.html
////

:toc:
:numbered:

////
Settings:
////
:miscellaneous.newline: \n

= Swift/T Developers' Guide
February 2016

== Conceptual overview

The premise of Swift/T is to 1) translate a Swift script into a
runnable format for execution at very large scale, on MPI, and 2) to
enable it to call into a variety of external code (leaf functions),
including the shell, native code libraries, and external scripting
languages.  Since Swift is primarily about distributing these leaf
functions, the key component of our runtime is ADLB.  Thus, we need to
translate Swift into an ADLB program.

We do this by first providing a convenient compiler target called
Turbine.  This provided a textual Tcl interface for our core runtime
features.  At runtime, we simply launch many Tcls across the machine
and allow them to communicate by calling into the ADLB library.  Thus,
we provide a Tcl extension for ADLB.  The rest of Turbine is just glue
code to 1) provide a more convenient compiler target and 2) provide
Swift features, such as its string library and interfaces to external
code. 

== Basic execution

. Swift/T typically starts with a user invocation of +swift-t+, a
simple shell script.  This invokes +stc+ and +turbine+, which are also
shell scripts.  All use +getopt+.  
. +stc+ translates the `getopt's to Java properties, to be passed into
the JVM via +java -D+.
. STC starts in +exm/stc/ui/Main.java+.  All properties are registered
in +exm/stc/common/Settings.java+.  STC emits a +*.tic+ file.
. Turbine starts as a parallel invocation of +tclsh+, each running the
STC-generated +*.tic+ file.  The beginning of the program is thus the
first commands in the +*.tic+ file, +turbine::defaults+ and so on.
These are defined in the Turbine +lib/+ directory, which contains all
the Tcl source and the Turbine shared object, which links to ADLB.
. ADLB is initiated and controlled through calls to its Tcl interface,
defined in +turbine/code/src/tcl/adlb+.

== STC internals

STC ingests a Swift file and emits a Tcl file for execution by
Turbine, called Turbine Intermediate Code (TIC).  It parses the Swift
code using ANTLR file +exm/stc/ast/ExM.g+.  When STC is built by Ant,
this file is translated into Java source code (see Ant target
+antlr.generate+).

When STC starts in +Main.java:main()+, it does three key things:
process options, preprocess the Swift code (via +cpp+), and call into
the +STCompiler+ class to perform translation.  This walks the
ANTLR-generated AST in +exm/stc/frontend/ASTWalker+.

Once translation and optimization are finished, an AST of Tcl code is
generated via the classes in +exm/stc/tclbackend/+.  This AST is then
converted to a string via recursive calls to the various +appendTo()+
methods in the +TclTree+ class, then simply written to the TIC file.

== Turbine internals

Consider this Tcl script (+f.tcl+): 

----
puts "HI"
----

This can be run as an MPI program:

----
$ mpiexec -n 2 f.tcl
HI
HI
----

Turbine simply runs the same thing:

----
$ turbine f.tcl
HI
HI
----

At first glance, Turbine is simply a parallel Tcl interpreter.
However, Turbine also provides the +turbine+ Tcl package, which
contains the contents of the +lib/+ directory: Tcl scripts and a
shared object.  These provide all the TIC features nencessary for STC.


////
Local Variables:
mode: doc
eval: (auto-fill-mode 1)
End:
////
