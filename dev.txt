
////
Swift/T developers' guide, asciidoc format
http://swift-lang.github.io/swift-t/dev.html
////

:toc:
:numbered:

////
Settings:
////
:miscellaneous.newline: \n

= Swift/T Developers' Guide
February 2016

== Conceptual overview

The premise of Swift/T is to 1) translate a Swift script into a
runnable format for execution at very large scale, on MPI, and 2) to
enable it to call into a variety of external code (leaf functions),
including the shell, native code libraries, and external scripting
languages.  Since Swift is primarily about distributing these leaf
functions, the key component of our runtime is ADLB.  Thus, we need to
translate Swift into an ADLB program.

We do this by first providing a convenient compiler target called
Turbine.  This provided a textual Tcl interface for our core runtime
features.  At runtime, we simply launch many Tcls across the machine
and allow them to communicate by calling into the ADLB library.  Thus,
we provide a Tcl extension for ADLB.  The rest of Turbine is just glue
code to 1) provide a more convenient compiler target and 2) provide
Swift features, such as its string library and interfaces to external
code. 

== Basic execution

. Swift/T typically starts with a user invocation of +swift-t+, a
simple shell script.  This invokes +stc+ and +turbine+, which are also
shell scripts.  All use +getopt+.  
. +stc+ translates the `getopt's to Java properties, to be passed into
the JVM via +java -D+.
. STC starts in +exm/stc/ui/Main.java+.  All properties are registered
in +exm/stc/common/Settings.java+.  STC emits a +*.tic+ file.
. Turbine starts as a parallel invocation of +tclsh+, each running the
STC-generated +*.tic+ file.  The beginning of the program is thus the
first commands in the +*.tic+ file, +turbine::defaults+ and so on.
These are defined in the Turbine +lib/+ directory, which contains all
the Tcl source and the Turbine shared object, which links to ADLB.
. ADLB is initiated and controlled through calls to its Tcl interface,
defined in +turbine/code/src/tcl/adlb+.

== STC internals

STC ingests a Swift file and emits a Tcl file for execution by
Turbine, called Turbine Intermediate Code (TIC).  It parses the Swift
code using ANTLR file +exm/stc/ast/ExM.g+.  When STC is built by Ant,
this file is translated into Java source code (see Ant target
+antlr.generate+).

When STC starts in +Main.java:main()+, it does three key things:
process options, preprocess the Swift code (via +cpp+), and call into
the +STCompiler+ class to perform translation.  This walks the
ANTLR-generated AST in +exm/stc/frontend/ASTWalker+.

Once translation and optimization are finished, an AST of Tcl code is
generated via the classes in +exm/stc/tclbackend/+.  This AST is then
converted to a string via recursive calls to the various +appendTo()+
methods in the +TclTree+ class, then simply written to the TIC file.

== Turbine internals

Consider this Tcl script (+f.tcl+): 

----
puts "HI"
----

This can be run as an MPI program:

----
$ mpiexec -n 2 f.tcl
HI
HI
----

Turbine simply runs the same thing:

----
$ turbine f.tcl
HI
HI
----

At first glance, Turbine is simply a parallel Tcl interpreter.
However, Turbine also provides the +turbine+ Tcl package, which
contains the contents of the +lib/+ directory: Tcl scripts and a
shared object.  These provide all the TIC features nencessary for STC.

=== Builtins

Turbine implements the Swift/T standard library in +export+.  Some
libraries (e.g., string) are implemented in pure Tcl.  Other TIC
features are implemented in C code exposed to Tcl in +src/tcl+.  For
example, +string.swift:sprintf()+ refers to Tcl function +sprintf+
which is implemented in +lib/string.tcl+, which simply uses the Tcl
function +format+.  The +sprintf+ function operates on Turbine data
(TDs), which are integers that are the identifiers of data stored in
ADLB.  A +rule+ is used to trigger data-dependent execution, described
next.

=== Turbine data

When Swift code declares, reads, or writes data, these are translated
into ADLB data operations +_Create()+, +_Retrieve()+, and +_Store()+
(see +adlb.h+).  These functions are exposed to TIC as Tcl functions
+adlb::create+, +adlb::retrieve+, and +adlb::store+.  However,
higher-level wrapper interfaces are targeted by STC, found in
+lib/data.tcl+.  These handle the various types, provide logging, and
so on.  They also support the Swift/T reference-counting-based garbage
collection scheme (+_incr+ and +_decr+ generally refer to this count,
when it reaches 0, the variable is garbage-collected by ADLB).

=== The Turbine rule statement




////
Local Variables:
mode: doc
eval: (auto-fill-mode 1)
End:
////
